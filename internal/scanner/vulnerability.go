package scanner

import (
        "bytes"
        "strings"

        "github.com/yourusername/cryptoscan/pkg/types"
)

// Known vulnerable crypto patterns
var (
        // Weak or deprecated algorithms that should be avoided
        weakAlgorithms = map[string]string{
                "MD2":      "Cryptographically broken and should never be used",
                "MD4":      "Cryptographically broken and should never be used",
                "MD5":      "Cryptographically broken and should never be used",
                "SHA1":     "Cryptographically broken for digital signatures",
                "DES":      "Key size too small, vulnerable to brute force attacks",
                "3DES":     "Vulnerable to Sweet32 attack and slow",
                "RC2":      "Key size too small, vulnerable to related-key attacks",
                "RC4":      "Multiple vulnerabilities in the cipher",
                "Blowfish": "Key size and block size too small",
                "IDEA":     "Patents and limited keys make it problematic",
                "SEED":     "Limited adoption and analysis",
        }
        
        // Recommended minimum key lengths for various algorithms
        insecureKeyLengths = map[string]struct {
                Min       int
                Preferred int
                Comment   string
        }{
                "RSA":   {Min: 2048, Preferred: 4096, Comment: "RSA with 2048 bits is the minimum acceptable, 4096 bits preferred for longer term security"},
                "DSA":   {Min: 2048, Preferred: 3072, Comment: "DSA with less than 2048 bits is insecure"},
                "EC":    {Min: 224, Preferred: 256, Comment: "Elliptic curves smaller than 224 bits are insecure"},
                "DH":    {Min: 2048, Preferred: 3072, Comment: "Diffie-Hellman parameters less than 2048 bits are insecure"},
                "AES":   {Min: 128, Preferred: 256, Comment: "AES with 128 bits is the minimum, 256 bits preferred for sensitive data"},
                "ECDSA": {Min: 224, Preferred: 256, Comment: "ECDSA with P-224 is the minimum, P-256 or higher preferred"},
                "EdDSA": {Min: 255, Preferred: 255, Comment: "Ed25519 (255 bits) is the recommended EdDSA variant"},
        }
        
        // Weak elliptic curves that should be avoided
        weakECCurves = map[string]string{
                "secp192r1":   "192-bit curve is too weak for modern use",
                "secp224r1":   "224-bit curve is at the minimum acceptable level",
                "P-192":       "192-bit curve is too weak for modern use",
                "P-224":       "224-bit curve is at the minimum acceptable level",
                "prime192v1":  "192-bit curve is too weak for modern use",
                "prime224v1":  "224-bit curve is at the minimum acceptable level",
                "sect163k1":   "163-bit curve is too weak for modern use",
                "sect163r1":   "163-bit curve is too weak for modern use",
                "sect163r2":   "163-bit curve is too weak for modern use",
                "sect193r1":   "193-bit curve is too weak for modern use",
                "sect193r2":   "193-bit curve is too weak for modern use",
        }
        
        // Insecure crypto modes
        insecureModes = map[string]string{
                "ECB":      "ECB mode is deterministic and reveals patterns in the plaintext",
                "OFB":      "OFB mode can be vulnerable if not implemented correctly",
                "CBC-MAC":  "CBC-MAC is not secure for variable length messages",
                "CBC-CS1":  "Non-standard CBC ciphertext stealing mode",
                "CBC-CS2":  "Non-standard CBC ciphertext stealing mode",
                "CBC-CS3":  "Non-standard CBC ciphertext stealing mode",
        }
        
        // Recommended modes and patterns
        recommendedPatterns = map[string]string{
                "AEAD":     "Authenticated Encryption with Associated Data provides confidentiality and authenticity",
                "GCM":      "Galois/Counter Mode provides authenticated encryption",
                "ChaCha20-Poly1305": "Modern authenticated encryption combination",
                "CTR + HMAC": "Counter mode with HMAC for authentication is a secure pattern",
                "CBC + HMAC": "CBC with HMAC for authentication is acceptable",
        }
        
        // Crypto implementations with known vulnerabilities or poor track records
        problematicImplementations = map[string]string{
                "OpenSSL < 1.1.0": "Older OpenSSL versions have numerous vulnerabilities",
                "wolfSSL < 4.5.0": "Older wolfSSL versions have vulnerabilities",
                "LibreSSL < 2.8.0": "Older LibreSSL versions have vulnerabilities",
                "BouncyCastle < 1.65": "Older BouncyCastle versions have vulnerabilities",
                "crypto-js":   "JavaScript crypto library not suitable for high-security use cases",
                "sjcl < 1.0.8": "Stanford JavaScript Crypto Library older versions have weaknesses",
        }
        
        // Low risk practices that should be reviewed but aren't critical
        lowRiskPractices = map[string]string{
                "PBKDF2 < 10000": "PBKDF2 with iteration count less than 10000 may be vulnerable to brute force attacks",
                "SHA256": "SHA256 is acceptable for most uses but not ideal for password hashing",
                "SHA512": "SHA512 is acceptable for most uses but not ideal for password hashing",
                "AES-128": "AES-128 is acceptable but AES-256 is preferred for long-term security",
                "RSA-2048": "RSA with 2048 bits is acceptable but consider upgrading to 4096 bits for future-proofing",
                "CTR": "CTR mode is secure but doesn't provide authentication",
                "CBC": "CBC mode is acceptable but modern AEAD modes preferred",
        }
)

// CheckVulnerabilities checks a finding for known vulnerabilities
func CheckVulnerabilities(finding types.Finding) []types.Vulnerability {
        var vulnerabilities []types.Vulnerability
        
        // Check for weak algorithms
        for algo, reason := range weakAlgorithms {
                lowerAlgo := strings.ToLower(algo)
                if strings.Contains(strings.ToLower(finding.Content), lowerAlgo) {
                        vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                Type:        "Weak Algorithm",
                                Description: "Using weak or deprecated algorithm: " + algo + " - " + reason,
                                Severity:    "HIGH",
                                Reference:   "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html",
                        })
                }
        }
        
        // Check for insecure modes
        for mode, reason := range insecureModes {
                lowerMode := strings.ToLower(mode)
                if strings.Contains(strings.ToLower(finding.Content), lowerMode) {
                        vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                Type:        "Insecure Mode",
                                Description: "Using insecure cipher mode: " + mode + " - " + reason,
                                Severity:    "HIGH",
                                Reference:   "https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation",
                        })
                }
        }
        
        // Check for problematic implementations
        for impl, reason := range problematicImplementations {
                lowerImpl := strings.ToLower(impl)
                if strings.Contains(strings.ToLower(finding.Content), lowerImpl) {
                        vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                Type:        "Problematic Implementation",
                                Description: "Using problematic crypto implementation: " + impl + " - " + reason,
                                Severity:    "MEDIUM",
                                Reference:   "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Implementation_Cheat_Sheet.html",
                        })
                }
        }
        
        // Check for weak curves in EC keys
        if finding.Type == "EC Private Key" {
                for curve, reason := range weakECCurves {
                        if strings.Contains(finding.Content, curve) {
                                vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                        Type:        "Weak Curve",
                                        Description: "Using weak elliptic curve: " + curve + " - " + reason,
                                        Severity:    "HIGH",
                                        Reference:   "https://safecurves.cr.yp.to/",
                                })
                        }
                }
        }
        
        // Check for key exposure in private keys
        if strings.Contains(finding.Type, "Private Key") || 
           finding.Type == "OpenSSH Private Key" ||
           finding.Type == "PGP Private Key Block" ||
           finding.Type == "DSA Private Key" {
                vulnerabilities = append(vulnerabilities, types.Vulnerability{
                        Type:        "Key Exposure",
                        Description: "Private key material checked into repository",
                        Severity:    "CRITICAL",
                        Reference:   "https://owasp.org/www-community/vulnerabilities/Cryptographic_Storage_Insufficient",
                })
        }
        
        // Check for hardcoded credentials
        credentialTypes := []string{
                "AWS Access Key", "AWS Secret Key", "Google API Key", "Google OAuth", 
                "Stripe API Key", "Stripe Publishable Key", "GitHub Token", "GitHub OAuth",
                "JWT Token", "Base64 Key",
        }
        
        for _, credType := range credentialTypes {
                if finding.Type == credType {
                        vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                Type:        "Hardcoded Credential",
                                Description: "Hardcoded " + credType + " in source code",
                                Severity:    "CRITICAL",
                                Reference:   "https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_credentials",
                        })
                        break
                }
        }
        
        // For crypto implementation files, check for common insecure patterns
        if finding.Type == "Crypto Implementation" {
                // Check for potentially insecure randomness
                if (bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("random")) ||
                    bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("rand.")) ||
                    bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("math/rand"))) &&
                   !bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("secureandom")) &&
                   !bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("crypto/rand")) {
                        vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                Type:        "Insecure Randomness",
                                Description: "Potentially insecure random number generation - not using cryptographically secure random number generator",
                                Severity:    "HIGH",
                                Reference:   "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation",
                        })
                }
                
                // Check for static IVs or nonces
                if (bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("iv")) ||
                    bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("nonce"))) &&
                   (bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("static")) ||
                    bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("const")) ||
                    bytes.Contains(bytes.ToLower([]byte(finding.Content)), []byte("="))) {
                        vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                Type:        "Static IV",
                                Description: "Potentially using static initialization vector (IV) or nonce which can lead to cryptographic weaknesses",
                                Severity:    "HIGH",
                                Reference:   "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html",
                        })
                }
                
                // Check for lack of authentication
                if strings.Contains(strings.ToLower(finding.Content), "encrypt") &&
                   !strings.Contains(strings.ToLower(finding.Content), "mac") &&
                   !strings.Contains(strings.ToLower(finding.Content), "auth") &&
                   !strings.Contains(strings.ToLower(finding.Content), "hmac") &&
                   !strings.Contains(strings.ToLower(finding.Content), "gcm") &&
                   !strings.Contains(strings.ToLower(finding.Content), "poly1305") {
                        vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                Type:        "Missing Authentication",
                                Description: "Encryption without authentication detected - use authenticated encryption",
                                Severity:    "MEDIUM",
                                Reference:   "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#authenticated-encryption",
                        })
                }
        }
        
        // Check for low risk practices
        for practice, reason := range lowRiskPractices {
                lowerPractice := strings.ToLower(practice)
                if strings.Contains(strings.ToLower(finding.Content), lowerPractice) {
                        vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                Type:        "Suboptimal Practice",
                                Description: "Using practice that could be improved: " + practice + " - " + reason,
                                Severity:    "LOW",
                                Reference:   "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html",
                        })
                }
        }
        
        // Check for low-risk public key issues
        if strings.Contains(finding.Type, "Public Key") {
                // Public keys are not inherently vulnerable but leaving them in source code might not be best practice
                vulnerabilities = append(vulnerabilities, types.Vulnerability{
                        Type:        "Public Key Exposure",
                        Description: "Public key material in repository - consider using a key server or certificate store",
                        Severity:    "LOW",
                        Reference:   "https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html",
                })
        }
        
        // Check for other low-risk indicators
        lowRiskKeywords := []struct {
                Keyword     string
                VulnType    string
                Description string
        }{
                {
                        Keyword:     "TODO: security",
                        VulnType:    "Security TODO",
                        Description: "Security-related TODO comment found - indicates known security task",
                },
                {
                        Keyword:     "FIXME: crypto",
                        VulnType:    "Crypto FIXME",
                        Description: "Cryptography-related FIXME comment found - indicates known issue",
                },
                {
                        Keyword:     "password",
                        VulnType:    "Password Reference",
                        Description: "Password reference found - ensure proper password handling",
                },
                {
                        Keyword:     "plaintext",
                        VulnType:    "Plaintext Reference",
                        Description: "Plaintext data reference found - ensure sensitive data is encrypted",
                },
        }
        
        for _, item := range lowRiskKeywords {
                if strings.Contains(strings.ToLower(finding.Content), strings.ToLower(item.Keyword)) {
                        vulnerabilities = append(vulnerabilities, types.Vulnerability{
                                Type:        item.VulnType,
                                Description: item.Description,
                                Severity:    "LOW",
                                Reference:   "https://owasp.org/www-project-top-ten/",
                        })
                }
        }
        
        return vulnerabilities
}
